# HTTP 정리

## 1. HTTP란?

HTTP(HyperText Transfer Protocol)는 웹에서 클라이언트와 서버 간 데이터를 주고받기 위한 프로토콜이다. 주로 HTML 문서, 이미지, 동영상 등의 리소스를 전달하는 데 사용된다. 하지만 단순한 웹 페이지뿐만 아니라 JSON, XML, 텍스트 파일, 바이너리 데이터 등 거의 모든 형태의 데이터를 전송할 수 있다.

### 특징:

- **클라이언트-서버 구조(Client-Server Architecture)**: HTTP는 클라이언트(예: 웹 브라우저)와 서버 간의 요청 및 응답을 기반으로 동작하는 구조이다.
- **비연결(Connectionless)**: 요청을 보내고 응답을 받으면 연결을 종료한다.
- **무상태(Stateless)**: 각 요청은 독립적이며, 이전 요청과의 상태를 유지하지 않는다.
- **TCP/IP 기반**: 일반적으로 TCP를 사용하며, HTTP/3에서는 UDP 기반의 QUIC 프로토콜을 활용한다.
- **다양한 데이터 형식 지원**: JSON, XML, HTML, 이미지, 동영상, 바이너리 데이터 등 모든 형태의 데이터 전송 가능.
- **단순함(Simple) 및 확장 가능성(Scalability)**: HTTP는 설계가 단순하여 다양한 애플리케이션에서 쉽게 구현 가능하며, REST API 등과 결합하여 높은 확장성을 제공한다.

---

## 2. HTTP의 역사

| 버전     | 연도 | 특징                                                                                                                                  |
| -------- | ---- | ------------------------------------------------------------------------------------------------------------------------------------- |
| HTTP/0.9 | 1991 | 단순한 GET 요청만 지원                                                                                                                |
| HTTP/1.0 | 1996 | 요청/응답 헤더 도입, 상태 코드 추가 (TCP 기반)                                                                                        |
| HTTP/1.1 | 1997 | 지속적 연결(Persistent Connection) 지원 (RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)) - 현재 가장 많이 사용되는 HTTP 버전 |
| HTTP/2.0 | 2015 | 성능 개선, 다중화(Multiplexing), 헤더 압축 도입, 요청 및 응답 병렬 처리 (TCP 기반)                                                    |
| HTTP/3.0 | 2022 | 성능 개선 극대화, QUIC 프로토콜 기반, UDP 활용 (UDP 기반)                                                                             |

---

## 3. HTTP의 통신 구조

```plaintext
클라이언트 (브라우저)  →  HTTP 요청  →  서버 (웹 서버)
클라이언트 (브라우저)  ←  HTTP 응답  ←  서버 (웹 서버)
```

---

## 4. HTTP의 무상태성 - Stateless

### 4.1 상태 유지 (Stateful)

- 서버가 클라이언트의 이전 요청 상태를 저장하고 관리하는 방식.
- 항상 같은 서버가 요청을 처리해야 하므로 로드 밸런싱이 어렵고 특정 서버가 과부하될 가능성이 있음.
- 클라이언트는 필요한 요청 정보를 저장하지 않으며, 모든 상태 정보는 서버가 관리해야 함.

### 4.2 무상태 (Stateless)

- 서버가 클라이언트의 이전 요청 정보를 저장하지 않는 방식.
- 클라이언트가 요청 시 필요한 모든 정보를 포함하여 보내야 함.
- 요청을 처리하는 서버가 고정되지 않으므로 여러 서버를 증설하여 부하를 쉽게 분산할 수 있음.

### 4.3 Stateful vs Stateless 비교표

| 구분                      | Stateful                                                               | Stateless                                                                                         |
| ------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
| 상태 유지                 | 서버가 세션 정보를 저장하며, 항상 같은 서버에서 요청을 처리해야 함     | 요청마다 독립적으로 처리되며, 여러 서버에서 부하 분산 가능                                        |
| 클라이언트 요청 방식      | 클라이언트는 상태 정보를 따로 보관하지 않으며, 서버가 모든 상태를 관리 | 클라이언트가 필요한 모든 요청 정보를 포함하여 서버로 전송                                         |
| 확장성                    | 서버가 세션을 관리해야 하므로 확장에 제약이 있음                       | 서버 간 부하를 분산할 수 있어 **스케일 아웃(Scale-out)**, 즉 수평 확장(Horizontal Scaling)에 유리 |
| 장점                      | 사용자의 연속적인 경험 제공, 특정 사용자 맞춤 데이터 제공 가능         | 서버 부하가 적고 장애 대응이 용이하며, 대규모 트래픽을 처리하기 쉬움                              |
| 단점                      | 서버 부하 증가, 특정 서버 장애 시 전체 서비스에 영향                   | 클라이언트가 매번 인증해야 함                                                                     |
| 장애 발생 시 (서버)       | 특정 서버가 다운되면 해당 서버에 연결된 사용자는 서비스 이용 불가      | 요청을 처리할 다른 서버가 존재하므로 자동으로 장애 대응 가능                                      |
| 장애 발생 시 (클라이언트) | 서버 장애 시 세션이 끊어져 다시 로그인해야 할 수도 있음                | 클라이언트는 어느 서버에 연결되든 동일한 요청을 보낼 수 있음                                      |
| 로그인 예시               | 로그인 세션을 유지하기 위해 서버가 사용자 정보를 저장                  | 클라이언트가 매 요청마다 인증 정보를 포함하여 서버에 보냄                                         |

**스케일 아웃(Scale-out)이란?**

- 서버의 성능을 높이기 위해 기존 서버의 성능을 향상(Scale-up)하는 대신, 여러 대의 서버를 추가하여 부하를 분산하는 방식이다.
- **Stateless 시스템은 상태를 저장하지 않기 때문에 여러 서버에서 부하를 쉽게 분산할 수 있어 스케일 아웃(수평 확장, Horizontal Scaling)에 용이하다.**

---

## 5. HTTP의 비연결성 - Connectionless

### 5.1 연결을 유지하는 모델

- 연결을 유지하면, 서버와 클라이언트의 연결은 서로의 네트워크 요청이 없더라도 계속해서 유지됨.
- 서버 자원이 지속적으로 사용되므로, HTTP는 기본적으로 연결을 유지하지 않는 모델을 채택함.

### 5.2 연결을 유지하지 않는 모델

- 연결을 유지하지 않으면, 서버의 자원을 효율적으로 사용할 수 있음.
- TCP 3-way handshake를 매번 수행해야 하므로 속도 저하 발생.
- **HTTP 지속 연결(Persistent Connections)** 및 **HTTP/2, HTTP/3의 최적화**로 해결됨.

### 5.3 비연결성 한계 - 단기 커넥션

- 초기 HTTP에서는 요청마다 TCP 연결을 맺어야 했으며, 성능 저하가 심각했음.

### 5.4 비연결성 극복 - HTTP 지속 연결

- HTTP/1.1부터 **지속 연결(Persistent Connection)**을 지원.
- **HTTP/2.0:** 다중화(Multiplexing), 헤더 압축, 서버 푸시 도입.
- **HTTP/3.0:** QUIC 프로토콜 사용, UDP 기반, 0-RTT 핸드셰이크 도입.

---

## 6. HTTP 메시지

### 6.1 HTTP 요청 메시지

#### **📌 HTTP 요청 메시지 구조**

```plaintext
METHOD 요청 URI HTTP/버전
헤더(Header)
빈 줄
바디(Body) (필요한 경우)
```

**예제 (GET 요청)**

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

**예제 (POST 요청)**

```
POST /login HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 29

username=user&password=1234
```

| 구성 요소                   | 설명                                                                   |
| --------------------------- | ---------------------------------------------------------------------- |
| **요청 라인(Request Line)** | HTTP 메서드(GET, POST 등), 요청 URI, HTTP 버전 포함                    |
| **헤더(Header)**            | 요청 관련 부가 정보 포함 (예: `Host`, `User-Agent`, `Content-Type` 등) |
| **빈 줄**                   | 헤더와 본문(Body) 사이 구분 역할                                       |
| **본문(Body)**              | POST, PUT 요청에서 데이터 포함 (GET 요청에서는 생략)                   |

### 6.2 HTTP 응답 메시지

#### **📌 HTTP 응답 메시지 구조**

```plaintext
HTTP/버전 상태 코드 상태 메시지
헤더(Header)
빈 줄
바디(Body)
```

**예제 (성공 응답)**

```
HTTP/1.1 200 OK
Date: Mon, 13 Mar 2025 12:00:00 GMT
Content-Type: text/html
Content-Length: 1256

<html>
  <head><title>Example</title></head>
  <body><h1>Welcome to Example</h1></body>
</html>
```

| 구성 요소                  | 설명                                                               |
| -------------------------- | ------------------------------------------------------------------ |
| **상태 라인(Status Line)** | HTTP 버전, 상태 코드(200, 404), 상태 메시지 포함                   |
| **헤더(Header)**           | 응답 관련 부가 정보 포함 (예: `Content-Type`, `Date`, `Server` 등) |
| **빈 줄**                  | 헤더와 본문(Body) 사이 구분                                        |
| **본문(Body)**             | HTML, JSON, 이미지 등 서버가 반환하는 데이터                       |

## 7. 참고 링크

> [HTTP 개요 및 백엔드 로드맵 - Inpa's Blog](https://inpa.tistory.com/entry/HTTP-%F0%9F%8C%90-%EB%B0%B1%EC%97%94%EB%93%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5-HTTP%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94#http%EC%9D%98_%ED%86%B5%EC%8B%A0_%EA%B5%AC%EC%A1%B0)

> [MDN Web Docs - HTTP 개요](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)
> [김영한님 인프런 강의 - HTTP 웹 네트워크 개념](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

<details>
  <summary>
 📌 발표 스크립트 및 대본
  </summary>

### 🎤 발표 시작

안녕하세요, 여러분! 오늘은 웹 개발자라면 꼭 알아야 하는 HTTP 프로토콜에 대해 간략히 소개하겠습니다.

### 1. HTTP란 무엇인가?

HTTP(HyperText Transfer Protocol)는 클라이언트와 서버 간 데이터를 주고받는 규칙입니다. 흔히 웹 브라우저가 서버로부터 웹페이지나 이미지를 불러올 때 사용하는 방식입니다. 하지만 웹페이지뿐만 아니라 JSON이나 동영상 등 다양한 데이터도 전송할 수 있습니다.

예를 들어, 브라우저에서 네이버를 열면, 브라우저가 네이버 서버에 "메인 페이지를 주세요"라고 요청하고, 서버는 그 요청을 받아 HTML 문서를 보내줍니다.

---

### 2. HTTP의 주요 특징

- **클라이언트-서버 구조**: 브라우저가 요청하면 서버가 응답하는 방식입니다.
- **무상태(Stateless)**: 서버가 이전 요청을 기억하지 않고 각각의 요청을 독립적으로 처리합니다.
- **비연결성(Connectionless)**: 요청마다 연결을 유지하지 않고 매번 연결을 새로 맺습니다.

예를 들어, 로그인할 때 매번 아이디와 패스워드를 보내야 하는 이유도 바로 이 무상태성 때문입니다.

---

### 3. HTTP의 역사와 발전

HTTP는 버전별로 성능이 계속 발전해왔습니다. 특히 HTTP/1.1에서 지속 연결을 지원하게 되어 성능이 많이 좋아졌습니다. 최근 HTTP/2와 HTTP/3는 성능을 더욱 높이고, 데이터 전송을 빠르게 해주는 기능들을 포함하고 있습니다.

간단히 말하면, 과거에는 매 요청마다 연결을 맺느라 느렸던 것이, 최근에는 한 번의 연결로 여러 요청을 동시에 처리할 수 있게 되었습니다.

---

### 4. HTTP 메시지 구조

HTTP 메시지는 요청과 응답으로 나뉩니다.

- 요청 메시지는 메서드(GET, POST 등), URI, 헤더, 바디를 포함합니다.

  ```http
  GET /index.html HTTP/1.1
  Host: www.example.com
  ```

- 응답 메시지는 상태 코드(200, 404 등), 헤더, 본문을 포함합니다.

  ```http
  HTTP/1.1 200 OK
  Content-Type: text/html
  ```

예를 들어, 서버가 성공적으로 페이지를 보내면 상태 코드 200을 반환하고, 페이지를 찾을 수 없으면 404를 반환합니다.

---

### 5. HTTP의 무상태성과 비연결성 극복 방법

HTTP는 기본적으로 무상태, 비연결성을 가졌지만, 이를 극복하기 위해 쿠키나 세션, 그리고 최근에는 JWT(JSON Web Token)를 사용합니다. 또 HTTP/2와 HTTP/3에서는 연결을 계속 유지하며 성능을 개선하고 있습니다.

예를 들어, 온라인 쇼핑몰에서 장바구니 정보가 유지되는 것이 바로 쿠키나 세션 덕분입니다.

---

🎤 이상으로 HTTP에 대한 발표를 마치겠습니다. 감사합니다!

---

</details>

<details>
  <summary>
  📋질문 리스트
  </summary>
  <details>
    <summary><strong>1. HTTP의 무상태성(stateless)이란 무엇이며, 장점과 단점에 대해 설명해 보세요.</strong></summary>

> HTTP의 무상태성(stateless)이란, 서버가 클라이언트의 이전 요청 정보를 저장하지 않고 각각의 요청을 독립적으로 처리하는 방식을 의미합니다.  
> 예를 들어, 쇼핑몰에서 상품을 클릭할 때마다 서버는 이전에 사용자가 어떤 상품을 클릭했는지 기억하지 않고 각 요청을 개별적으로 처리합니다.
>
> 장점으로는 여러 서버에서 부하 분산이 쉽기 때문에 확장성이 뛰어나고, 특정 서버 장애에도 시스템 전체에 영향이 적습니다.  
> 단점으로는 사용자가 매번 요청 시 로그인 정보 등 동일한 인증 정보를 계속 보내야 하는 불편함이 있습니다.

</details>

<details>
<summary><strong>2. HTTP/1.1과 HTTP/2의 주요 차이점은 무엇인가요?</strong></summary>

> HTTP/1.1과 HTTP/2의 주요 차이점은 성능 최적화 방식입니다.  
> HTTP/1.1은 요청마다 개별 연결을 하거나 제한된 병렬 처리를 하는 반면, HTTP/2는 단일 연결 내에서 여러 요청과 응답을 동시에 처리할 수 있는 다중화(multiplexing) 기능과 헤더 압축을 통해 성능을 크게 향상시켰습니다.  
> 예를 들어, 웹페이지 로딩 시 이미지, CSS, JavaScript 파일을 동시에 빠르게 받아올 수 있게 되어 사용자 경험이 개선됩니다.

</details>

<details>
<summary><strong>3. HTTP 요청 메시지의 구조와 각 부분의 역할에 대해 설명해 주세요.</strong></summary>

> HTTP 요청 메시지는 다음과 같은 구조를 갖습니다:
>
> ```plaintext
> METHOD 요청URI HTTP버전
> 헤더(Header)
> 빈 줄
> 바디(Body)
> ```
>
> 예를 들어, 로그인 시 POST 요청을 보내면:
>
> ```plaintext
> POST /login HTTP/1.1
> Host: www.example.com
> Content-Type: application/x-www-form-urlencoded
> Content-Length: 29
>
> username=user&password=1234
> ```
>
> - **요청 라인**: 요청 방식(GET, POST 등), 요청할 리소스 경로, HTTP 버전 정보를 포함합니다.
> - **헤더**: 요청에 대한 부가 정보를 서버에 제공합니다(예: Host, Content-Type).
> - **바디**: 주로 POST, PUT 요청 시 서버에 전송할 데이터를 포함하며, GET 요청에서는 생략됩니다.

</details>

<details>
<summary><strong>4. HTTP의 비연결성(connectionless)의 의미와 이를 극복하는 방법에 대해 설명해 보세요.</strong></summary>

> HTTP의 비연결성(connectionless)은 요청과 응답 후 연결을 바로 종료하는 방식으로, 서버 자원을 효율적으로 사용할 수 있지만, 매 요청마다 새로운 연결을 맺어야 하므로 성능이 떨어질 수 있습니다.  
> 예를 들어 초기 HTTP에서는 이미지 여러 장을 로드할 때마다 새로 연결을 맺느라 속도가 느렸습니다.
>
> 이를 극복하기 위해 HTTP/1.1부터 지속 연결(persistent connection)이 도입되었고, 최근 HTTP/2와 HTTP/3에서는 연결 유지 및 다중화(multiplexing), 헤더 압축 등으로 성능 문제를 해결했습니다.

</details>

<details>
<summary><strong>5. HTTP 상태 코드란 무엇이며, 자주 쓰이는 상태 코드의 예시를 들어 설명해 보세요.</strong></summary>

> HTTP 상태 코드는 클라이언트의 요청 처리 결과를 나타내는 세 자리 숫자 코드입니다.
>
> 자주 쓰이는 코드의 예시는 다음과 같습니다:
>
> - **200 OK**: 요청이 성공적으로 처리되었음을 의미합니다. (예: 정상적인 웹페이지 로딩)
> - **404 Not Found**: 요청한 리소스가 존재하지 않음을 나타냅니다. (예: 존재하지 않는 웹페이지 접근 시)
> - **500 Internal Server Error**: 서버 내부 오류로 요청을 처리할 수 없음을 나타냅니다. (예: 서버 오류로 웹페이지 표시 불가 시)

</details>
</details>
