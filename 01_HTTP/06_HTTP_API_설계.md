## 🔹 1. HTTP API 설계: POST 기반 등록 - collection

### ✅ 1-1. 설계 원칙 설명

- **리소스를 URI로 식별하는 것이 핵심**

  - RESTful한 API 설계에서는 리소스(Resource)를 고유하게 식별할 수 있는 **URI (Uniform Resource Identifier)** 를 정의하는 것이 가장 중요함.
  - 예: `/members/123` → ID가 123인 `member` 리소스를 의미.

- **Collection 기반 설계**

  - URI는 일반적으로 **복수형 명사**를 사용하여 리소스의 집합(Collection)을 표현함.  
    예: `/members`, `/products`

- **POST는 Collection에 리소스를 등록할 때 사용**

  - 클라이언트가 서버에 새 리소스를 생성 요청할 때 `POST /members`와 같이 Collection URI를 사용함.
  - 생성된 리소스의 ID는 서버에서 생성해 반환함.

- **Control URI는 예외 상황에서 사용**
  - 리소스 자체를 명확히 식별하기 어렵거나, 리소스가 아닌 **동작(Action)** 을 수행해야 하는 경우 사용.
  - 예: `/members/login`, `/orders/123/cancel`
  - 이처럼 **명사 기반 URI 설계 원칙**을 따르되, 필요한 경우에만 제한적으로 **동사 기반 Control URI**를 허용함.

### ✅ 1-2. 설계 예시 (리소스: `members` Collection 기준)

> 가정: `members`는 회원 정보를 담은 리소스이며, 각 회원은 `id`를 통해 식별할 수 있음.

| 기능           | 메서드   | URI 예시               | 설명                                                              |
| -------------- | -------- | ---------------------- | ----------------------------------------------------------------- |
| 회원 목록 조회 | `GET`    | `/members`             | 모든 회원 목록 조회                                               |
| 회원 등록      | `POST`   | `/members`             | 새로운 회원 등록 (서버가 ID를 생성)                               |
| 회원 상세 조회 | `GET`    | `/members/{id}`        | 특정 회원 정보 조회                                               |
| 회원 정보 수정 | `PUT`    | `/members/{id}`        | **전체 정보 교체** (리소스를 완전히 덮어씀)                       |
|                | `PATCH`  | `/members/{id}`        | **일부 정보 수정** (부분 수정 시 사용 👍)                         |
|                | `POST`   | `/members/{id}/update` | (Control URI 대안) 수정이 복잡하거나 PUT/PATCH가 애매한 경우 사용 |
| 회원 삭제      | `DELETE` | `/members/{id}`        | 특정 회원 삭제                                                    |

### 🔸 1-2-(1). POST - 신규 자원 등록 특징

- **클라이언트는 등록될 리소스의 URI를 모른다**

  - 클라이언트는 생성할 리소스의 URI를 미리 지정하지 않음.
  - 예: 회원 등록 시

    ```http
    POST /members
    Content-Type: application/json

    {
      "name": "Alice",
      "email": "alice@example.com"
    }
    ```

- **서버가 새로 등록된 리소스 URI를 생성해서 응답**

  - 서버는 새로운 자원의 고유 ID를 생성하고, `Location` 헤더에 해당 URI를 포함시켜 반환함.
    ```http
    HTTP/1.1 201 Created
    Location: /members/123
    ```

- **PUT과의 차이점**
  | 항목 | POST | PUT |
  |-------------|----------------------------------------|--------------------------------------|
  | 리소스 URI | 서버가 생성 | 클라이언트가 명시적으로 지정 |
  | 사용 목적 | **새로운 자원 생성** | **자원 전체 수정 or 새로 생성 (덮어쓰기)** |
  | 대상 URI | 일반적으로 Collection URI 사용 | 리소스 개별 URI 사용 |

- **컬렉션 (Collection)**
  - **정의**: 동일한 종류의 리소스를 모은 집합
  - **URI 생성 및 관리 주체**: **서버**
  - **예시에서의 컬렉션**: `/members` → 전체 회원 리소스의 모음

## 🔹 2. HTTP API 설계: POST / PUT 기반 등록

### 2-1. 설계 원칙 설명

**RESTful API 설계에서 POST와 PUT은 자원을 등록(생성)할 때 사용되는 메서드입니다.** 이때 사용하는 HTTP 메서드는 다음 원칙에 따라 결정됩니다:

| 메서드   | 특징                                             |
| -------- | ------------------------------------------------ |
| **POST** | 서버 측에서 자원의 URI를 생성 (서버 주도)        |
| **PUT**  | 클라이언트가 자원의 URI를 명시 (클라이언트 주도) |

- **POST**: 보통 서버에 새로운 자원을 생성할 때 사용하며, 자원의 URI는 서버가 결정합니다.
- **PUT**: 클라이언트가 리소스의 URI를 알고 있고, 그 위치에 자원을 새로 만들거나 덮어쓸 때 사용됩니다.

### 2-2. 설계 예시

#### 가정

- `files`는 회원 정보를 담은 **리소스 저장소(store)**.
- 각 `file`은 고유한 `filename`으로 구분.
- 클라이언트가 직접 `filename`을 지정하거나, 서버가 지정할 수 있음.

#### API 설계

| 동작           | Method | URI                 | 설명                                             |
| -------------- | ------ | ------------------- | ------------------------------------------------ |
| 파일 목록 조회 | GET    | `/files`            | 모든 파일 목록을 조회                            |
| 파일 조회      | GET    | `/files/{filename}` | 특정 파일 조회                                   |
| 파일 등록      | PUT    | `/files/{filename}` | 클라이언트가 지정한 이름으로 파일 등록 또는 갱신 |
| 파일 삭제      | DELETE | `/files/{filename}` | 특정 파일 삭제                                   |
| 파일 대량 등록 | POST   | `/files`            | 서버가 여러 파일을 등록하고 URI 할당             |

### 2-2-(1). PUT - 신규 자원 등록 특징

#### ✅ 클라이언트가 리소스 URI를 알고 있어야 한다

- 클라이언트는 자원을 저장할 URI를 알고 있어야 하며, 해당 위치에 직접 업로드 가능
- **예시**:  
  클라이언트가 `john.json`이라는 회원 정보를 등록하고 싶다면  
  → `PUT /files/john.json` 으로 요청

#### ✅ 클라이언트가 직접 리소스의 URI를 지정한다

- 자원의 이름(`filename`)을 클라이언트가 직접 정하여 요청
- 서버는 클라이언트가 요청한 URI에 맞춰 자원을 저장하거나 갱신함

##### 🔸 POST와의 차이점

| 항목     | PUT                                  | POST                                                      |
| -------- | ------------------------------------ | --------------------------------------------------------- |
| URI 지정 | 클라이언트가 지정                    | 서버가 생성                                               |
| 용도     | 특정 위치에 새 자원 등록 or 덮어쓰기 | 새로운 자원 생성, 보통 여러 개 등록 or 서버 주도 URI 지정 |
| 멱등성   | **O** (같은 요청 반복해도 결과 동일) | **X** (요청마다 자원 추가됨)                              |

#### ✅ 스토어(Store)

- **Store**란 리소스의 집합을 의미하며, 클라이언트가 관리하는 저장소 역할
- 클라이언트가 어떤 리소스를 어느 URI에 저장할지 **직접 관리**
- `files`는 하나의 **스토어**로 간주되며, 클라이언트는 이 저장소 안의 리소스 URI(`/files/{filename}`)를 알고 있어야 함

---

## 3. 🔹 HTML FORM 사용 - 순수 HTML, HTML FORM을 사용한다는 가정

### - ✅ HTML FORM이 사용 가능한 메서드와 한계점

| 항목            | 설명                                                           |
| --------------- | -------------------------------------------------------------- |
| **지원 메서드** | `GET`, `POST`만 지원                                           |
| **한계점**      | `PUT`, `DELETE`, `PATCH` 등의 메서드는 FORM에서 직접 사용 불가 |
| **문제점**      | RESTful API처럼 모든 CRUD를 HTTP 메서드로 표현하기 어려움      |

### - ✅ AJAX 기술로 해결 가능한 점

| 항목             | 설명                                                             |
| ---------------- | ---------------------------------------------------------------- |
| **AJAX 사용 시** | JavaScript로 `PUT`, `DELETE`, `PATCH` 등 다양한 메서드 사용 가능 |
| **장점**         | 비동기 처리로 페이지 새로고침 없이 서버와 통신 가능              |
| **한계 극복**    | HTML FORM의 제약을 우회할 수 있음 → 더 RESTful한 설계 가능       |

## 3-1. 설계 원칙

### 📌 HTML FORM의 제약 → control URI 도입

- **FORM은 GET, POST만 지원** → DELETE, PUT 등은 직접 사용 불가능
- 그래서 **의미 있는 동작(삭제, 수정 등)을 동사 형태의 URI(control URI)** 로 설계
- 기본적으로는 RESTful 설계를 지향하되, 제약으로 인해 보완 방식 필요

## 3-2. 설계 예시

### 💡 가정

- `members`는 회원 정보가 저장된 **컬렉션(자원 집합)**
- 각 회원은 고유 `id`로 식별됨

| 기능           | Method | URI                                       | 설명                                   |
| -------------- | ------ | ----------------------------------------- | -------------------------------------- |
| 회원 목록 조회 | GET    | `/members`                                | 모든 회원 목록을 조회                  |
| 회원 등록 폼   | GET    | `/members/new`                            | 사용자에게 입력 폼 제공                |
| 회원 등록      | POST   | `/members` 또는 `/members/new`            | 회원 정보를 서버에 저장                |
| 회원 조회      | GET    | `/members/{id}`                           | 특정 회원 정보 조회                    |
| 회원 수정 폼   | GET    | `/members/{id}/edit`                      | 수정용 폼 제공                         |
| 회원 수정      | POST   | `/members/{id}` 또는 `/members/{id}/edit` | HTML FORM 제약으로 인해 POST 사용      |
| 회원 삭제      | POST   | `/members/{id}/delete`                    | FORM 제약 때문에 DELETE 대신 POST 사용 |

## 3-2-(1). Control URI

### 🔹 도입 배경

| 항목           | 설명                                                              |
| -------------- | ----------------------------------------------------------------- |
| HTML FORM 제약 | GET, POST만 사용 가능하므로 `DELETE`, `PUT` 불가능                |
| 대체 수단      | **동사 기반의 URI (Control URI)** 사용하여 의도 전달              |
| 예시 용도      | 삭제, 수정, 완료, 업로드 등 RESTful 메서드로 표현하기 애매한 경우 |
| 실무 활용      | **실무에서도 흔히 사용됨**, 특히 HTML 중심 페이지에서 많이 사용됨 |

### 🔹 Control URI 설계

- 일반적으로 RESTful URI는 자원 중심: `/members/{id}`
- 반면 **Control URI**는 **동작 중심**: `/members/{id}/delete`, `/members/{id}/edit`

### 🔍 위 예시에서 Control URI인 것들

| URI                    | 설명                                               |
| ---------------------- | -------------------------------------------------- |
| `/members/new`         | 등록 폼 → 등록 행위의 의미 포함 (동사 new)         |
| `/members/{id}/edit`   | 수정 폼, POST 요청 시 수정 실행 → edit은 동작 의미 |
| `/members/{id}/delete` | 삭제 요청 → delete는 명확한 동작 의미              |

> 이처럼 **`/new`, `/edit`, `/delete`** 등 동사 형태의 경로는 모두 **Control URI**입니다.  
> RESTful하게 자원을 표현할 수 없을 때 **우회적 방식**으로 활용됩니다.

다음은 **[🔹 URI 설계 시 참고하면 좋은 개념들]**을 핵심 키워드와 함께 정리한 내용입니다. 각 개념의 정의, 특징, 실제 API 예시를 중심으로 구성했습니다.

---

## 4. 🔹 URI 설계 시 참고하면 좋은 개념

### 4-1. 📄 문서 (Document)

- **정의**: 단일 개체 또는 개념을 표현하는 URI입니다. 해당 리소스는 고유하며, 하나의 단일 정보를 나타냅니다.
- **특징**:
  - 명확한 식별자(ID)를 가짐
  - 특정 리소스 인스턴스를 조회할 때 사용
  - CRUD 중 _READ_, _UPDATE_, _DELETE_ 요청에 주로 활용
- **예시**:
  - 파일 하나
  - 객체 인스턴스
  - 데이터베이스의 한 행(row)
- **실제 API 예시**:
  - `GET /users/123` → ID가 123인 사용자 정보 반환
  - `GET /posts/456` → ID가 456인 게시글 조회
  - `PUT /products/789` → 상품 정보 수정
  - `DELETE /comments/101` → 댓글 삭제

### 4-2. 📁 컬렉션 (Collection)

- **정의**: 같은 유형의 리소스들을 모아놓은 컨테이너입니다. 서버가 이 컨테이너의 URI 및 내부 리소스들의 URI를 생성하고 관리합니다.
- **특징**:
  - 리소스 그룹을 나타냄
  - 주로 _리스트 조회_ 또는 *새로운 리소스 생성*에 사용
  - 내부 항목들은 각각 고유한 Document URI를 가짐
- **예시**:
  - 사용자 목록
  - 게시글 목록
- **실제 API 예시**:
  - `GET /users` → 모든 사용자 리스트 반환
  - `POST /posts` → 새 게시글 생성 요청
  - `GET /products` → 상품 목록 조회

### 4-3. 🗃️ 스토어 (Store)

- **정의**: 클라이언트가 리소스의 URI를 직접 정의하고, 서버에 저장하는 방식입니다. 서버는 클라이언트가 요청한 URI를 그대로 저장하고 관리합니다.
- **특징**:
  - 클라이언트가 URI를 **선택하고 정의**함
  - 리소스의 위치나 이름을 클라이언트가 직접 제어
  - 주로 `PUT` 메서드를 사용
- **예시**:
  - 파일 업로드 경로 지정
  - 특정 사용자 ID에 직접 저장
- **실제 API 예시**:
  - `PUT /files/image123.jpg` → 클라이언트가 지정한 이름으로 이미지 업로드
  - `PUT /users/alice123/profile` → 사용자 alice123의 프로필 정보 저장

### 3-4. ⚙️ 컨트롤러 (Controller) / 컨트롤 URI

- **정의**: 단순한 리소스 조회나 저장을 넘어서 **특정 동작을 수행**해야 할 때 사용하는 URI입니다. 일반적인 CRUD 외의 **비즈니스 로직이나 프로세스** 처리가 필요할 경우 사용됩니다.
- **특징**:
  - URI에 **동사(Verb)**를 포함
  - 리소스가 아닌 **동작 중심**의 요청
  - 비동기 처리 또는 트리거 역할을 수행
- **예시**:
  - 이메일 인증
  - 결제 처리
  - 게시글 발행
- **실제 API 예시**:
  - `POST /users/123/verify-email` → 사용자 123의 이메일 인증 수행
  - `POST /posts/456/publish` → 게시글 456을 공개 처리
  - `POST /orders/complete` → 주문 완료 처리

---

## 📎 참고 출처

[Inflearn - 누구나 쉽게 이해하는 HTTP 네트워크 강의](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

---

---

<details>

<summary>
  <b> 🎤 발표 대본 및 스크립트 </b>
</summary>

### 🟦 [도입] 왜 API URI 설계가 중요할까?

> "RESTful API를 만든다"는 말 많이 들어보셨죠?  
> 하지만 **URI를 어떻게 설계해야 REST스럽게 만들 수 있을까?**  
> 실무에서는 POST, PUT, PATCH, DELETE가 언제 어떻게 쓰이는지가 핵심이에요.  
> 오늘은 그 중에서도 실무에서 자주 부딪히는 `POST`와 `PUT`의 차이, 그리고 **Control URI**의 필요성까지 예시 중심으로 풀어보겠습니다.

---

### 🟦 [1] URI 설계의 기본: 리소스를 명사로 표현하기

- API URI는 **리소스를 식별하는 주소**예요.
- 명사 중심으로, 복수형을 사용해서 컬렉션을 표현합니다.

예:

- `/members` → 회원 전체 (컬렉션)
- `/members/123` → ID가 123인 회원 (문서)

실제 코드에서 보면:

```http
GET /members          ← 회원 목록 조회
GET /members/123      ← 특정 회원 조회
```

---

### 🟦 [2] POST vs PUT – 무엇을 언제 쓸까?

#### 🔹 POST: 서버가 URI를 정함 (컬렉션 기반 등록)

- 클라이언트는 ID를 몰라요.
- 예: 신규 회원 가입

```http
POST /members
Content-Type: application/json

{
  "name": "Alice",
  "email": "alice@example.com"
}
```

> 서버가 `Location: /members/123` 같이 새 URI를 만들어줍니다.

#### 🔹 PUT: 클라이언트가 URI를 정함 (스토어 방식)

- 클라이언트가 직접 어디 저장할지 결정해요.
- 예: 프로필 사진 업로드

```http
PUT /files/profile-alice.png
```

> 클라이언트가 저장 위치를 아예 지정합니다.  
> **멱등성 있음** → 같은 요청 여러 번 보내도 결과 동일.

---

### 🟦 [3] HTML FORM 제약과 Control URI

- 순수 HTML FORM은 `GET`, `POST`만 지원해요.
- 그래서 `DELETE`, `PUT`을 못 씁니다.  
  → 실무에서 동사 기반의 **Control URI**가 등장합니다.

#### 예시:

| 기능         | URI                   | Method |
| ------------ | --------------------- | ------ |
| 회원 삭제    | `/members/123/delete` | POST   |
| 회원 수정 폼 | `/members/123/edit`   | GET    |
| 회원 등록 폼 | `/members/new`        | GET    |

> RESTful한 설계를 지향하되, HTML 제약 때문에 **Control URI로 우회**하는 실무가 많아요.

---

### 🟦 [4] 실무에서 만나는 URI 패턴 요약

| 패턴       | 설명                      | 예시 URI                  |
| ---------- | ------------------------- | ------------------------- |
| Document   | 단일 리소스 조회          | `/users/1`, `/products/3` |
| Collection | 리소스 목록 or 등록       | `/users`, `/products`     |
| Store      | 클라이언트 지정 URI 저장  | `/files/image1.png`       |
| Controller | 특정 동작 (동사 기반 URI) | `/orders/123/cancel`      |

> 각각의 URI 설계에는 **사용 목적**이 있고, 그에 따라 HTTP 메서드도 달라집니다.

---

### 🟦 [마무리] 핵심 요약

- URI는 **리소스 중심**으로 설계한다 (명사 기반).
- POST는 **서버가 URI를 정하고**, PUT은 **클라이언트가 URI를 정한다**.
- HTML FORM 제약 때문에 **Control URI도 실무에서 꼭 필요**하다.
- 실무에서는 REST 원칙과 현실적인 제약 사이의 균형이 중요합니다.

## </details>

<details>

<summary>
<b>
 ✅핵심 질문 5개
</b>
</summary>

---

### 💬 Q1. POST와 PUT의 차이를 설명해보세요.

**답변:**  
POST는 서버가 URI를 정하는 방식이고, PUT은 클라이언트가 URI를 지정하는 방식입니다.  
예를 들어, 신규 회원 가입은 `POST /members`처럼 서버가 ID를 생성해서 응답하죠.  
반면에 사용자가 직접 파일명을 지정해서 업로드할 때는 `PUT /files/report.pdf`처럼 클라이언트가 URI를 정합니다.

---

### 💬 Q2. PUT은 왜 멱등하다고 하나요?

**답변:**  
멱등성은 같은 요청을 여러 번 보내도 결과가 같다는 뜻입니다.  
PUT은 자원을 "덮어쓰기" 때문에, 같은 데이터를 같은 URI에 여러 번 보내도 최종 상태는 같습니다.  
예: `PUT /files/profile.png`를 반복 호출해도 같은 파일이 덮어씌워지죠.

---

### 💬 Q3. Control URI는 언제 필요할까요?

**답변:**  
HTML FORM처럼 `POST`, `GET`만 지원하는 환경에서는 `PUT`이나 `DELETE`를 직접 쓸 수 없습니다.  
이럴 땐 `/members/123/delete` 같은 Control URI를 사용해 동작을 표현합니다.  
실제로 서버 렌더링 기반 시스템에서 자주 사용합니다. 실무에서도 많이 봤습니다.

---

### 💬 Q4. RESTful하게 URI를 설계하는 기준은 무엇인가요?

**답변:**  
URI는 리소스를 식별하는 역할이기 때문에 **명사 중심**으로 설계해야 RESTful합니다.

- `/members`는 회원 목록이라는 컬렉션
- `/members/123`은 하나의 회원  
  그리고 동작은 HTTP 메서드로 표현해야 하고, 예외 상황에서만 Control URI를 사용합니다.

---

### 💬 Q5. POST는 왜 멱등하지 않은가요?

**답변:**  
POST는 서버가 리소스를 새로 생성할 때 사용됩니다.  
동일한 POST 요청을 두 번 보내면 리소스가 두 개 생길 수 있기 때문에 멱등하지 않습니다.  
예를 들어 회원 가입 API에 같은 요청을 두 번 보내면 `id=123`, `id=124` 두 개의 회원이 생성될 수 있어요.

---

</details>
