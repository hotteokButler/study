# **🔹 HTTP 메서드 속성 - 안전성, 멱등성, 캐시 가능성**

## **1. 안전성 (Safety)**

### **📌 개념 설명**

- **안전성(Safety)**이란, **요청을 여러 번 보내도 서버의 상태가 변경되지 않는 성질**을 의미함
- 즉, **데이터를 변경하는 부작용(Side Effect)이 발생하지 않는 HTTP 메서드는 안전한 메서드**
- 안전한 메서드는 주로 **조회(read-only) 목적으로 사용**됨

### **1.1. 안전한 메서드와 안전하지 않은 메서드 비교**

| 메서드      | 안전성 여부      | 설명                                         |
| ----------- | ---------------- | -------------------------------------------- |
| **GET**     | ✅ 안전함        | 데이터를 가져오는 요청 (조회)                |
| **HEAD**    | ✅ 안전함        | GET과 동일하지만, 응답 본문 없이 헤더만 반환 |
| **OPTIONS** | ✅ 안전함        | 서버에서 지원하는 메서드 목록 확인           |
| **POST**    | ❌ 안전하지 않음 | 서버에 데이터를 생성 (변경 가능)             |
| **PUT**     | ❌ 안전하지 않음 | 리소스를 전체 변경 (덮어쓰기)                |
| **PATCH**   | ❌ 안전하지 않음 | 리소스 일부만 변경                           |
| **DELETE**  | ❌ 안전하지 않음 | 리소스를 삭제                                |

### **📌 어떤 경우 안전하지 않은가?**

- **POST, PUT, PATCH, DELETE 요청을 보내면 서버의 데이터가 변경될 수 있음**
- 예를 들어, **게시판에서 댓글을 삭제하는 DELETE 요청**을 보냈을 때 서버의 데이터가 변경됨
- **반대로 GET 요청을 여러 번 보내도 서버의 데이터는 변경되지 않으므로 안전한 메서드**

✅ **안전한 메서드 예제 (GET 요청 - 조회만 수행)**

```http
GET /users/123 HTTP/1.1
Host: example.com
```

✅ **안전하지 않은 메서드 예제 (POST 요청 - 새로운 사용자 생성)**

```http
POST /users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Alice"
}
```

---

## **2. 멱등성 (Idempotency)**

### **📌 개념 설명**

- **멱등성(Idempotency)**이란, **같은 요청을 여러 번 보내도 결과가 동일한 성질**을 의미함
- 즉, **같은 요청을 반복적으로 보내도 서버의 상태가 변하지 않거나 동일한 결과가 보장되는 요청**
- 단, 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않음

### **2.1. 멱등성 메서드의 종류와 비멱등성 메서드 비교**

| 메서드     | 멱등성 여부       | 장애 발생 시 같은 요청을 다시 보내도 안전한가? | 설명                                                             |
| ---------- | ----------------- | ---------------------------------------------- | ---------------------------------------------------------------- |
| **GET**    | ✅ 멱등함         | **⭕ 가능**                                    | 데이터를 조회하는 요청이므로 재요청해도 결과가 동일              |
| **PUT**    | ✅ 멱등함         | **⭕ 가능**                                    | 같은 데이터를 같은 위치에 저장하면 결과가 동일                   |
| **DELETE** | ✅ 멱등함         | **⭕ 가능**                                    | 같은 리소스를 여러 번 삭제해도 최종 결과가 동일                  |
| **POST**   | ❌ 비멱등         | **❌ 불가능**                                  | 같은 요청을 여러 번 보내면 중복 데이터가 생성될 수 있음          |
| **PATCH**  | ❌ 비멱등(일반적) | **❌ 불가능**                                  | 일부만 변경하는 요청이므로 재요청 시 다르게 적용될 가능성이 있음 |

✅ **멱등한 요청 예제 (PUT 요청 - 기존 데이터 덮어쓰기)**

```http
PUT /users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Updated Alice"
}
```

- **PUT 요청을 여러 번 보내도 동일한 결과가 보장됨** (항상 같은 데이터로 덮어쓰기 때문)

❌ **멱등하지 않은 요청 예제 (POST 요청 - 데이터 중복 생성 가능)**

```http
POST /users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Alice"
}
```

- **POST 요청을 여러 번 보내면 같은 데이터가 중복 생성될 수 있음!**

### **2.2. 멱등성이 필요한 이유와 활용**

멱등성은 **HTTP 메서드 설계 시 매우 중요한 속성**이다.  
특히, **네트워크 장애나 서버 장애가 발생했을 때 자동 복구(재요청) 가능 여부를 판단하는 기준**이 된다.

📌 **예제 상황: 네트워크 타임아웃 발생**

- 클라이언트가 **서버에 HTTP 요청을 보냈지만, 타임아웃(timeout) 문제로 응답을 받지 못함**
- 클라이언트는 요청이 정상적으로 처리되었는지 알 수 없으므로 **같은 요청을 다시 전송**할 수도 있음
- 이때, **멱등한 메서드는 동일한 요청을 여러 번 보내도 결과가 변하지 않으므로 안전하게 재요청 가능**
- 하지만, **멱등하지 않은 메서드는 중복 실행될 경우 원치 않는 문제가 발생할 수 있음**

✅ **실무 활용 예시**

- **GET, PUT, DELETE 요청은 장애 발생 시 재요청이 가능하지만, POST, PATCH 요청은 중복 실행을 방지하는 추가 설계가 필요**
- **POST 요청에서는 "Client-Generated ID" 또는 "중복 방지 로직"을 사용하여 중복 생성을 방지**
- **PATCH 요청은 ETag, 버전 관리, If-Match 헤더 등을 활용하여 데이터 충돌 방지**

---

## **3. 캐시 가능 (Cacheable)**

### **📌 개념 설명**

- **캐시(Cache)**란, **자주 사용하는 데이터를 임시로 저장하여 서버 요청을 줄이고 성능을 향상시키는 방식**
- HTTP에서 **일부 메서드는 캐싱이 가능하고, 일부는 캐싱이 불가능**함

---

### **3.1. 캐시란?**

- **웹 브라우저 또는 프록시 서버에서 서버의 응답을 저장하여 동일한 요청에 대한 재요청을 빠르게 처리하는 기법**
- **예를 들어, 이미지, CSS 파일, 자바스크립트 파일 등을 캐싱하여 성능을 최적화할 수 있음**

✅ **캐싱의 장점**

- **서버 부하 감소** (반복된 요청을 처리하지 않아도 됨)
- **응답 속도 향상** (네트워크 왕복 시간을 줄일 수 있음)

### **3.2. 캐시 가능한 메서드와 불가능한 메서드 비교**

| 메서드     | 캐싱 가능 여부 | 설명                                               |
| ---------- | -------------- | -------------------------------------------------- |
| **GET**    | ✅ 가능        | 조회 요청이므로 캐싱 가능                          |
| **HEAD**   | ✅ 가능        | 응답 본문 없이 헤더만 반환 (캐싱 유효성 검사 가능) |
| **POST**   | ❌ 불가능      | 데이터가 변경되므로 캐싱하면 안 됨                 |
| **PUT**    | ❌ 불가능      | 리소스 변경이므로 캐싱하면 안 됨                   |
| **PATCH**  | ❌ 불가능      | 일부 데이터 변경이므로 캐싱하면 안 됨              |
| **DELETE** | ❌ 불가능      | 리소스를 삭제하는 요청이므로 캐싱하면 안 됨        |

---

## 🔗 참고 자료

HTTP 메서드의 개념과 속성에 대한 더 자세한 내용은 아래 자료를 참고하세요:

- 📌 [HTTP 메서드 종류 및 속성 정리 - hstory0208 블로그](https://hstory0208.tistory.com/entry/HTTP-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A2%85%EB%A5%98-%EB%B0%8F-%EC%86%8D%EC%84%B1)
- 📌 [HTTP 메서드 속성 (안전성, 멱등성, 캐시성) - velog](https://velog.io/@cataiden/http-method-properties)
- 📌 [HTTP의 멱등성 · 안전성 · 캐시성 완벽 정리 - inpa 블로그](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1-%C2%B7-%EC%95%88%EC%A0%95%EC%84%B1-%C2%B7-%EC%BA%90%EC%8B%9C%EC%84%B1-%F0%9F%92%AF-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
- 📌 [HTTP 메서드 속성 및 활용 - twojun 블로그](https://twojun-space.tistory.com/155)
- 📌 [김영한님 인프런 강의 - HTTP 웹 네트워크 개념](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

---

<details>
 <summary>
 <b>
  🎤 발표 대본 - HTTP 메서드 속성  
 </b>
 </summary>

## 🎤 발표 시작

안녕하세요! 오늘은 **HTTP 메서드의 속성**에 대해 이야기해보겠습니다.  
웹 개발에서 가장 기본적이면서도 중요한 개념 중 하나인데요,  
단순히 GET, POST 같은 메서드를 아는 것에서 그치는 것이 아니라,  
이들의 **속성(특징)**을 이해하는 것이 실제 서비스 개발에서 큰 도움이 됩니다.

---

## 🔹 HTTP 메서드의 3가지 주요 속성

오늘은 **안전성(Safety), 멱등성(Idempotency), 캐시 가능성(Cacheability)**  
이 세 가지를 중심으로 설명드릴게요.

## 1. 안전성 (Safety)

> **"여러 번 요청을 보내도 서버의 데이터가 변경되지 않는가?"**

즉, **데이터 변경이 없는 메서드**는 안전한 메서드입니다.

✅ **안전한 메서드 예시**

- `GET /users/123` → 사용자 정보를 조회
- `HEAD /users/123` → 사용자 정보가 있는지만 확인

⛔ **안전하지 않은 메서드 예시**

- `POST /users` → 새로운 사용자 추가 (데이터 변경 발생)
- `DELETE /users/123` → 사용자 삭제 (데이터 변경 발생)

💡 **실무 적용 예시**

- 은행 계좌 정보 조회 API (`GET`)는 여러 번 요청해도 데이터가 바뀌지 않아야 합니다.
- 하지만 **송금 API에서 `POST`를 사용하면**, 같은 요청을 반복해서 보내면 큰 문제가 됩니다!

## 2. 멱등성 (Idempotency)

> **"같은 요청을 여러 번 보내도 결과가 동일한가?"**

즉, **재요청이 안전한 메서드**를 의미합니다.

✅ **멱등한 메서드**

- `GET /users/123` → 사용자 정보 조회 (같은 응답 반환)
- `PUT /users/123` → 사용자 정보 덮어쓰기 (항상 같은 값으로 업데이트)
- `DELETE /users/123` → 이미 삭제된 상태라면, 다시 삭제 요청해도 영향 없음

⛔ **멱등하지 않은 메서드**

- `POST /users` → 같은 요청을 여러 번 보내면, 사용자 계정이 중복 생성될 수 있음
- `PATCH /users/123` → 일부 데이터만 변경하므로, 요청마다 다른 결과가 나올 수도 있음

💡 **실무 적용 예시**

- 쇼핑몰의 **"상품 주문하기" 버튼**을 중복 클릭하면 같은 상품이 여러 번 결제될 수도 있습니다!
- 이 문제를 방지하려면, **클라이언트에서 요청을 한 번만 보내도록 하거나, 서버에서 중복 요청을 차단하는 로직**이 필요합니다.

## 3. 캐시 가능성 (Cacheability)

> **"서버의 응답을 캐시에 저장하고 재사용할 수 있는가?"**

✅ **캐시 가능한 메서드**

- `GET /users/123` → 같은 사용자 정보를 계속 요청할 경우, 캐시 가능

⛔ **캐시 불가능한 메서드**

- `POST /users` → 새로운 데이터가 추가되므로, 캐싱하면 안 됨
- `PUT /users/123` → 데이터 변경이므로, 캐싱하면 안 됨

💡 **실무 적용 예시**

- 뉴스 사이트에서 인기 기사 페이지를 `GET` 요청하면,  
  **매번 서버에서 가져오는 것보다 캐싱을 활용하면 성능이 향상됩니다!**

---

## 🎤 마무리

오늘 **HTTP 메서드의 안전성, 멱등성, 캐시 가능성**을 설명드렸습니다.

✔ `GET`은 안전하고 멱등하며, 캐시 가능하다.  
✔ `POST`는 안전하지도 않고, 멱등하지 않으며, 캐시도 불가능하다.  
✔ `PUT`, `DELETE`는 멱등하지만, 안전하지 않다.  
✔ 캐시를 활용하면 성능을 개선할 수 있다.

이 개념들을 실무에서 잘 활용하면, 더 견고하고 확장성 있는 API 설계가 가능합니다!  
감사합니다! 😊

</details>

---

# 예상 질문 및 답변

## 1️⃣ GET과 POST의 차이점은 무엇인가요?

> ✅ **답변**
>
> GET과 POST는 HTTP에서 가장 많이 사용되는 메서드로, 각각의 목적과 동작 방식이 다릅니다.
>
> ### **1. GET 요청**
>
> - **목적:** 서버에서 데이터를 조회할 때 사용합니다.
> - **특징:**
> - 요청을 여러 번 보내도 서버의 상태가 변하지 않습니다. (**안전성 O**)
> - 같은 요청을 반복해도 동일한 응답을 받습니다. (**멱등성 O**)
> - 캐싱이 가능합니다. (**캐시 가능성 O**)
> - **예시:**
>
> ```http
> GET /users/123 HTTP/1.1
> Host: example.com
> ```
>
> ### **2. POST 요청**
>
> - **목적:** 서버에 데이터를 생성할 때 사용합니다.
> - **특징:**
> - 요청을 보낼 때마다 서버의 상태가 변경될 수 있습니다. (**안전성 X**)
> - 같은 요청을 여러 번 보내면 중복된 데이터가 생성될 수 있습니다. (**멱등성 X**)
> - 캐싱할 수 없습니다. (**캐시 가능성 X**)
> - **예시:**
>
> ```http
> POST /users HTTP/1.1
> Host: example.com
> Content-Type: application/json
>
> {
>   "name": "Alice"
> }
> ```
>
> 💡 **실무 적용 예시**
>
> - 사용자가 웹사이트에서 **로그인할 때**는 `POST /login` 요청을 보내고,
> - 사용자의 프로필 정보를 가져올 때는 `GET /users/123` 요청을 보냅니다.

---

> ## 2️⃣ PUT과 PATCH의 차이점은 무엇인가요?
>
> ✅ **답변**
>
> PUT과 PATCH는 모두 서버의 데이터를 변경하는 역할을 하지만, 동작 방식이 다릅니다.
>
> ### **1. PUT 요청 (전체 수정, Full Update)**
>
> - **목적:** 리소스를 **전체 변경**할 때 사용합니다.
> - **특징:**
>   - 기존 데이터를 **완전히 덮어씁니다.**
>   - 요청을 여러 번 보내도 같은 데이터로 덮어쓰기 때문에 **멱등성이 보장됩니다.**
>
> ### **2. PATCH 요청 (부분 수정, Partial Update)**
>
> - **목적:** 리소스의 **일부 필드만 변경**할 때 사용합니다.
> - **특징:**
>   - 기존 데이터 중 특정 필드만 변경할 수 있습니다.
>   - 요청마다 다른 데이터를 수정할 가능성이 있으므로, **멱등성이 보장되지 않을 수도 있습니다.**
>
> 💡 **실무 적용 예시**
>
> - 회원 정보 수정 시,
>   - **PUT**을 사용하면 이름, 이메일, 나이 등 모든 정보를 덮어씁니다.
>   - **PATCH**를 사용하면 특정 필드(예: 전화번호)만 변경할 수 있습니다.

---

## 3️⃣ 멱등성이 중요한 이유는 무엇인가요?

> ✅ **답변**
>
> 멱등성이 중요한 이유는 **네트워크 장애나 서버 오류로 인해 같은 요청이 여러 번 전송될 가능성이 있기 때문입니다.**
>
> 💡 **실무 적용 예시**
>
> - 쇼핑몰에서 **결제 요청을 POST로 보낸 경우**,
>   - 네트워크 오류로 인해 동일한 요청이 다시 전송되면,
>   - 같은 상품이 두 번 결제될 수 있습니다.
>   - 이를 방지하기 위해 **중복 요청을 차단하는 로직**이 필요합니다.

---

## 4️⃣ HTTP 요청이 캐시되도록 설정하려면 어떻게 해야 하나요?

> ✅ **답변**
>
> HTTP에서 응답을 캐싱하려면 `Cache-Control` 또는 `ETag` 헤더를 설정해야 합니다.
>
> ### **1. Cache-Control 헤더를 사용한 캐싱 설정**
>
> - `Cache-Control: max-age=3600` → 응답을 1시간(3600초) 동안 캐시합니다.
> - `Cache-Control: no-cache` → 캐시를 사용할 수 있지만, 매번 서버에서 유효성 검사를 해야 합니다.
> - `Cache-Control: no-store` → 민감한 정보(로그인 세션 등)는 절대 캐싱되지 않도록 설정합니다.
>
> ### **2. ETag 헤더를 사용한 캐싱 설정**
>
> - **ETag(Entity Tag)는 서버에서 응답 데이터를 식별하기 위해 사용하는 고유한 값입니다.**
> - 클라이언트가 이후에 같은 요청을 보낼 때, `If-None-Match` 헤더에 기존 `ETag` 값을 포함하면,  
>   변경이 없을 경우 `304 Not Modified` 응답을 반환하여 네트워크 트래픽을 줄일 수 있습니다.
> - 즉, **불필요한 데이터 전송을 줄이고 성능을 향상시키는 중요한 캐싱 메커니즘입니다.**
>
> 💡 **실무 적용 예시**
>
> - 정적인 리소스(이미지, CSS, JS 파일 등)는 `Cache-Control: max-age=31536000`을 설정하여 장기간 캐싱할 수 있습니다.
> - API 응답에서 `ETag`를 활용하면 불필요한 데이터 전송을 줄이고 성능을 향상시킬 수 있습니다.

---

## 5️⃣ DELETE 요청이 캐시될 수 있나요?

> ✅ **답변**
>
> DELETE 요청은 리소스를 삭제하는 작업이므로, **캐싱되면 안 됩니다.**  
> 만약 DELETE 요청이 캐싱되면, 사용자가 데이터를 삭제한 후에도 여전히 존재하는 것처럼 보일 수 있습니다.
>
> ### **캐시 방지를 위한 설정**
>
> - DELETE 요청의 응답 헤더에 `Cache-Control: no-store`를 설정하면 캐싱이 방지됩니다.
> - 또는, 서버에서 DELETE 요청을 받을 때마다 항상 새로운 응답을 생성하도록 설정할 수도 있습니다.
>
> 💡 **실무 적용 예시**
>
> - 회원 탈퇴 요청 (`DELETE /users/123`) 후에도 사용자의 정보가 캐시에 남아 있으면,  
>   사용자가 로그아웃 후 다시 로그인했을 때 여전히 계정이 존재하는 것처럼 보일 수 있습니다.  
>   이를 방지하기 위해 DELETE 요청의 응답에 `Cache-Control: no-store`를 설정해야 합니다.
